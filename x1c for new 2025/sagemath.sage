# Part 1 functions
class AES:
    def __init__(self, key, round = 10):
        self.s_box = (
            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
            0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
            0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
            0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
            0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
            0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
            0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
            0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
            0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
            0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
            0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
        )
        self.inv_s_box = (
            0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
            0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
            0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
            0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
            0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
            0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
            0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
            0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
            0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
            0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
            0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
        )
        self.r_con = (
            0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
        )
        self.key = key
        self.rnd = round
        self.round_keys = self._key_expansion()

    def _sub_word(self, word):
        return bytes(self.s_box[b] for b in word)

    def _rot_word(self, word):
        return word[1:] + word[:1]

    def _key_expansion(self):
        round_keys = [self.key]
        for i in range(self.rnd):
            prev_key = round_keys[-1]
            temp = self._rot_word(prev_key[-4:])
            temp = self._sub_word(temp)
            temp = bytes([temp[0] ^^ self.r_con[i]]) + temp[1:]
            new_key = bytes([prev_key[j] ^^ temp[j] for j in range(4)])
            for k in range(4, 16, 4):
                new_key += bytes([prev_key[j+k] ^^ new_key[j+k-4] for j in range(4)])
            round_keys.append(new_key)
        return round_keys

    def _sub_bytes(self, state):
        return bytes(self.s_box[b] for b in state)

    def _inv_sub_bytes(self, state):
        return bytes(self.inv_s_box[b] for b in state)

    def _shift_rows(self, state):
        return bytes([
            state[0], state[5], state[10], state[15],
            state[4], state[9], state[14], state[3],
            state[8], state[13], state[2], state[7],
            state[12], state[1], state[6], state[11]
        ])

    def _inv_shift_rows(self, state):
        return bytes([
            state[0], state[13], state[10], state[7],
            state[4], state[1], state[14], state[11],
            state[8], state[5], state[2], state[15],
            state[12], state[9], state[6], state[3]
        ])

    def _mix_columns(self, state):
        new_state = bytearray(16)
        for i in range(0, 16, 4):
            a, b, c, d = state[i:i+4]
            new_state[i] = (self._gmul(a, 2) ^^ self._gmul(b, 3) ^^ c ^^ d)
            new_state[i+1] = (a ^^ self._gmul(b, 2) ^^ self._gmul(c, 3) ^^ d)
            new_state[i+2] = (a ^^ b ^^ self._gmul(c, 2) ^^ self._gmul(d, 3))
            new_state[i+3] = (self._gmul(a, 3) ^^ b ^^ c ^^ self._gmul(d, 2))
        return bytes(new_state)

    def _inv_mix_columns(self, state):
        new_state = bytearray(16)
        for i in range(0, 16, 4):
            a, b, c, d = state[i:i+4]
            new_state[i] = (self._gmul(a, 0x0e) ^^ self._gmul(b, 0x0b) ^^ 
                          self._gmul(c, 0x0d) ^^ self._gmul(d, 0x09))
            new_state[i+1] = (self._gmul(a, 0x09) ^^ self._gmul(b, 0x0e) ^^ 
                            self._gmul(c, 0x0b) ^^ self._gmul(d, 0x0d))
            new_state[i+2] = (self._gmul(a, 0x0d) ^^ self._gmul(b, 0x09) ^^ 
                            self._gmul(c, 0x0e) ^^ self._gmul(d, 0x0b))
            new_state[i+3] = (self._gmul(a, 0x0b) ^^ self._gmul(b, 0x0d) ^^ 
                            self._gmul(c, 0x09) ^^ self._gmul(d, 0x0e))
        return bytes(new_state)

    def _gmul(self, a, b):
        p = 0
        for _ in range(8):
            if b & 1:
                p ^^= a
            hi_bit_set = a & 0x80
            a <<= 1
            if hi_bit_set:
                a ^^= 0x1b
            b >>= 1
        return p & 0xff

    def encrypt(self, plaintext):
        state = self._add_round_key(plaintext, self.round_keys[0])
        for i in range(1, self.rnd):
            state = self._sub_bytes(state)
            state = self._shift_rows(state)
            state = self._mix_columns(state)
            state = self._add_round_key(state, self.round_keys[i])
        state = self._sub_bytes(state)
        state = self._shift_rows(state)
        state = self._add_round_key(state, self.round_keys[self.rnd])
        return state

    def decrypt(self, ciphertext):
        state = self._add_round_key(ciphertext, self.round_keys[self.rnd])
        state = self._inv_shift_rows(state)
        state = self._inv_sub_bytes(state)
        for i in range(self.rnd - 1, 0, -1):
            state = self._add_round_key(state, self.round_keys[i])
            state = self._inv_mix_columns(state)
            state = self._inv_shift_rows(state)
            state = self._inv_sub_bytes(state)
        state = self._add_round_key(state, self.round_keys[0])
        return state

    def _add_round_key(self, state, round_key):
        return bytes(s ^^ k for s, k in zip(state, round_key))

Sbox = (
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
)

InvSbox = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

Rcon = (
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
)

def inv_shift_rows(s):
    a = list(s)
    a[1], a[5], a[9], a[13] = a[13], a[1], a[5], a[9]
    a[2], a[6], a[10], a[14] = a[10], a[14], a[2], a[6]
    a[3], a[7], a[11], a[15] = a[7], a[11], a[15], a[3]
    return bytes(a)

def inv_sub_bytes(s):
    return bytes(InvSbox[x] for x in s)

def xor(a, b):
    return bytes([x ^^ y for x, y in zip(a, b)])

def key_from_round_key(key_list, n = 4):
    round_keys = [[] for _ in range(n+1)]
    round_keys[-1] = key_list
    for i in range(n-1,-1,-1):
        new_key = [0 for _ in range(16)]
        for j in range(3,0,-1):
            new_key[j*4:(j+1)*4] = [x^^y for x,y in zip(round_keys[i+1][j*4:(j+1)*4],round_keys[i+1][(j-1)*4:j*4])]
        tmp = new_key[-4:]
        tmp = tmp[1:] + tmp[:1]
        tmp = bytes([Sbox[b] for b in tmp])
        tmp = bytes([tmp[0] ^^ Rcon[i]]) + tmp[1:]
        new_key[:4] = [x^^y for x,y in zip(round_keys[i+1][:4], tmp)]
        round_keys[i] = new_key
    return bytes(round_keys[0])

def pad(msg:bytes):
    ll = 16 - len(msg) % 16
    return msg + bytes([ll] * ll)

def get_round_key_4(c4_set):
    predict_round_key_4 = [[] for _ in range(16)]
    for key_index in range(16):
        for key in range(0x100):
            round_key = [0 for _ in range(16)]
            round_key[key_index] = key
            round_key = bytes(round_key)
            c3_set = []
            for c4 in c4_set:
                c3 = xor(c4, round_key)
                c3 = inv_shift_rows(c3)
                c3 = inv_sub_bytes(c3)
                c3_set.append(c3)
            t = 0
            for i in range(0x100):
                t ^^= c3_set[i][(key_index+4*(key_index%4))%16]
            if t == 0:
                predict_round_key_4[key_index] += [key]
                print(f"key index: {key_index}, probable key: {hex(key)}")
    return predict_round_key_4

# Part 2 functions
def solveDL():
    while True:
        p = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF
        a = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC
        b = randint(1, p)
        E = EllipticCurve(GF(p), [a, b])
        order = E.order()
        factors = prime_factors(order)

        valid = []
        for factor in factors:
            if factor <= 2**40:
                valid.append(factor)
        if len(valid) == 0:
            continue
        prime = valid[-1]
        if int(prime).bit_length() < 20:
            continue

        G = E.gen(0) * int(order / prime)

        # Here we send G to the server
        tmp_point = G.xy()
        tmp_x, tmp_y = str(tmp_point[0]), str(tmp_point[1])
        if tmp_x != 0 and tmp_y != 0:
            break
    io.sendlineafter(b"[-] Your option:", b"2")
    io.sendlineafter(b"x coordinate:", tmp_x.encode())
    io.sendlineafter(b"y coordinate:", tmp_y.encode())

    # We get back Q which is G * k
    io.recvuntil(b"The shared key is: ")
    data = io.recvline().strip().decode().split(", ")
    print(data)
    try:
        Qx = int(data[0][1:])
        Qy = int(data[1][:-1])
    except:
        return None, None

    try:
        Q = E(Qx, Qy)
        print("Computing the discrete log problem")
        log = G.discrete_log(Q)
        print(f"DL found: {log}, {prime}")
        return (log, prime)
    except Exception as e:
        print(e)
        return None, None


def getDLs():
    dlogs = []
    primes = []
    for i in range(20):
        log, prime = solveDL()
        if log != None:
            dlogs.append(log)
            primes.append(prime)
        print(f"counter: {i}")
    return dlogs, primes

__import__('os').environ['TERM'] = 'xterm'

from Crypto.Util.number import *
from pwn import *
from hashlib import sha256


addr = "101.43.42.132 1721".split()
io = remote(addr[0], int(addr[1]))

# Part 1 AES square attack
lucky_set, c4_set = [], []
atp = 2025
while len(lucky_set) < 256:
    if atp == 0:
        print("[-] AES key is not found",len(lucky_set))
        exit()
    atp -= 1
    io.sendlineafter(b"[-] Your option:", b"1")
    io.recvuntil(b"[+] Today my lucky byte is:")
    lucky = bytes.fromhex(io.recvline().strip().decode())
    io.recvuntil(b"[+] And the ciphertext is: ")
    ciphertext = bytes.fromhex(io.recvline().strip().decode())
    if lucky not in lucky_set:
        lucky_set += [lucky]
    if ciphertext not in c4_set:
        c4_set += [ciphertext]

assert len(c4_set) == 256
print("[+] get lambda set")

predict_round_key_4 = get_round_key_4(c4_set)

from itertools import product

for i in product(*predict_round_key_4):
    key = key_from_round_key(bytes(i))
    aes = AES(key,4)
    for i in range(0x100):
        if aes.encrypt(pad(lucky_set[i])) != c4_set[i]:
            break
    else:
        print(f"[+] found AES key: {key.hex()}")
        break

# Part 2 ECC invalid curve attack
dlogs, primes = getDLs()
d = crt(dlogs, primes)
print(f"[+] found d: {d} bit length: {int(d).bit_length()}")
hashval = sha256(long_to_bytes(d) + key).hexdigest()

io.sendlineafter(b"[-] Your option:", b"3")
io.sendlineafter(b"[-] Give me the hash value:", hashval.encode())

io.interactive()